<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üö¥‚Äç‚ôÄÔ∏è Rate Your Track Bogot√°</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Leaflet.js pour les cartes interactives -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Donn√©es des pistes cyclables int√©gr√©es -->
    <script src="./data/pistes-data.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'DM Sans', sans-serif;
            background-color: #fafafa;
            color: #333;
            line-height: 1.6;
        }
        
        header {
            background: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .logo {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2563eb;
        }
        
        nav {
            display: flex;
            gap: 2rem;
            margin-top: 1rem;
        }
        
        nav button {
            background: none;
            border: 2px solid transparent;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-family: inherit;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        nav button:hover {
            background-color: #f1f5f9;
        }
        
        nav button.active {
            background-color: #2563eb;
            color: white;
        }
        
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .section {
            display: none;
            background: white;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .section.active {
            display: block;
        }
        
        .section h2 {
            color: #1e40af;
            margin-bottom: 1rem;
            font-size: 1.8rem;
        }
        
        .placeholder {
            background: #f8fafc;
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            padding: 3rem 2rem;
            text-align: center;
            color: #64748b;
            margin-top: 1rem;
        }
        
        /* Styles pour le syst√®me de notation */
        .rating-panel {
            position: absolute;
            top: 80px;
            left: 20px;
            z-index: 1200;
            background: rgba(255,255,255,0.98);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            width: 300px;
            font-family: 'DM Sans', sans-serif;
            opacity: 0;
            transform: translateX(-60px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }
        
        .rating-panel.show {
            opacity: 1;
            transform: translateX(0);
            pointer-events: auto;
        }
        
        .rating-panel h4 {
            margin: 0 0 15px 0;
            color: #1e40af;
            font-size: 1.1rem;
            font-weight: 600;
        }
        
        .rating-criteria {
            margin-bottom: 15px;
        }
        
        .rating-criteria label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            font-weight: 500;
            color: #374151;
        }
        
        .rating-slider {
            width: 100%;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: none;
            margin-bottom: 5px;
        }
        
        .rating-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .rating-slider.security::-webkit-slider-thumb { background: #dc2626; }
        .rating-slider.noise::-webkit-slider-thumb { background: #ca8a04; }
        .rating-slider.air::-webkit-slider-thumb { background: #16a34a; }
        .rating-slider.flow::-webkit-slider-thumb { background: #2563eb; }
        .rating-slider.inclusion::-webkit-slider-thumb { background: #7c3aed; }

        /* Styles pour les tooltips personnalis√©s */
        .custom-tooltip {
            background: white !important;
            border: 2px solid #2563eb !important;
            border-radius: 8px !important;
            padding: 8px 12px !important;
            font-size: 13px !important;
            line-height: 1.4 !important;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15) !important;
            max-width: 300px !important;
        }
        
        .custom-tooltip::before {
            border-top-color: #2563eb !important;
        }
        
        .rating-value {
            display: inline-block;
            background: #f3f4f6;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            min-width: 20px;
            text-align: center;
        }
        
        .rating-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn.primary {
            background: #2563eb;
            color: white;
        }
        
        .btn.primary:hover {
            background: #1d4ed8;
        }
        
        .btn.secondary {
            background: #6b7280;
            color: white;
        }
        
        .btn.secondary:hover {
            background: #4b5563;
        }
        
        .rating-info {
            font-size: 0.85rem;
            color: #6b7280;
            margin-top: 10px;
            padding: 8px;
            background: #f9fafb;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">üö¥‚Äç‚ôÄÔ∏è Rate Your Track Bogot√°</div>
        <nav>
            <button class="nav-btn active" data-section="accueil">Accueil</button>
            <button class="nav-btn" data-section="forum">Forum</button>
            <button class="nav-btn" data-section="carte-existantes">Pistes existantes</button>
            <button class="nav-btn" data-section="carte-souhaitees">Pistes souhait√©es</button>
            <button class="nav-btn" data-section="apropos">√Ä propos</button>
        </nav>
    </header>

    <main>
        <!-- Section Accueil -->
        <section class="section active" id="accueil">
            <h2>üåç Bienvenue sur Rate Your Track Bogot√°</h2>
            <p>Un site collaboratif pour am√©liorer les pistes cyclables de Bogot√° !</p>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-top: 2rem;">
                <div style="background: #f0f9ff; padding: 1.5rem; border-radius: 8px;">
                    <h3>üó£Ô∏è Forum</h3>
                    <p>Discutez avec la communaut√© cycliste</p>
                </div>
                <div style="background: #f0fdf4; padding: 1.5rem; border-radius: 8px;">
                    <h3>üó∫Ô∏è √âvaluez les pistes</h3>
                    <p>Notez la s√©curit√©, le bruit, la qualit√© de l'air...</p>
                </div>
                <div style="background: #fef3f2; padding: 1.5rem; border-radius: 8px;">
                    <h3>‚ú® Proposez des am√©liorations</h3>
                    <p>Tracez de nouvelles pistes sur la carte</p>
                </div>
            </div>
        </section>

        <!-- Section Forum -->
        <section class="section" id="forum">
            <h2>üó£Ô∏è Forum de discussion</h2>
            <p>Espace de discussion pour la communaut√© cycliste de Bogot√°</p>
            <div class="placeholder">
                Interface du forum √† venir...
                <br>Style inspir√© des forums classiques
            </div>
        </section>

        <!-- Section Carte Existantes -->
        <section class="section" id="carte-existantes">
            <h2>üó∫Ô∏è Pistes cyclables existantes</h2>
            <p>√âvaluez les pistes selon 5 crit√®res : S√©curit√©, Bruit, Qualit√© de l'air, Fluidit√©, Accessibilit√©</p>
            
            <!-- Contr√¥les interactifs -->
            <div style="display: flex; gap: 1rem; margin: 1rem 0; flex-wrap: wrap; align-items: center; padding: 1rem; background: white; border-radius: 8px; border: 1px solid #e5e7eb;">
                <button id="toggle-tracing" onclick="toggleTracingMode()" style="padding: 0.5rem 1rem; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                    üõ£Ô∏è Mode trac√© OFF
                </button>

                <button id="clear-route-btn" onclick="clearCurrentRoute(); updateTracingStatus();" style="padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem; display: none;">
                    üóëÔ∏è Effacer trac√©
                </button>

                <button id="toggle-ratings-display" onclick="toggleRatingsDisplay()" style="padding: 0.5rem 1rem; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                    üëÅÔ∏è Afficher les avis
                </button>
                <select id="view-selector" onchange="changeView()" style="padding: 0.5rem; border-radius: 6px; border: 1px solid #d1d5db; font-size: 0.9rem;">
                    <option value="global">üó∫Ô∏è Vue globale</option>
                    <option value="security">üõ°Ô∏è S√©curit√©</option>
                    <option value="noise">üîä Bruit</option>
                    <option value="air">üå¨Ô∏è Qualit√© air</option>
                    <option value="flow">‚ö° Fluidit√©</option>
                    <option value="inclusion">üë• Inclusion</option>
                </select>
                <span id="tracing-status" style="color: #6b7280; font-size: 0.9rem;"></span>
            </div>
            
            <!-- Carte interactive avec panneau de notation -->
            <div style="position: relative;">
                <div id="map-existantes" style="height: 500px; margin-top: 1rem; border-radius: 8px; border: 1px solid #e2e8f0;"></div>
                
                <!-- Panneau de notation -->
                <div id="rating-panel" class="rating-panel">
                    <h4 id="segment-name">Noter ce segment</h4>
                    
                    <div class="rating-criteria">
                        <label>üõ°Ô∏è S√©curit√© <span class="rating-value" id="security-value">1</span></label>
                        <input type="range" class="rating-slider security" id="security-slider" min="1" max="5" value="1">
                    </div>
                    
                    <div class="rating-criteria">
                        <label>üîä Bruit <span class="rating-value" id="noise-value">1</span></label>
                        <input type="range" class="rating-slider noise" id="noise-slider" min="1" max="5" value="1">
                    </div>
                    
                    <div class="rating-criteria">
                        <label>üå¨Ô∏è Qualit√© de l'air <span class="rating-value" id="air-value">1</span></label>
                        <input type="range" class="rating-slider air" id="air-slider" min="1" max="5" value="1">
                    </div>
                    
                    <div class="rating-criteria">
                        <label>‚ö° Fluidit√© <span class="rating-value" id="flow-value">1</span></label>
                        <input type="range" class="rating-slider flow" id="flow-slider" min="1" max="5" value="1">
                    </div>
                    
                    <div class="rating-criteria">
                        <label>üë• Inclusion <span class="rating-value" id="inclusion-value">1</span></label>
                        <input type="range" class="rating-slider inclusion" id="inclusion-slider" min="1" max="5" value="1">
                    </div>
                    
                    <div class="rating-criteria">
                        <label>üí¨ Commentaire (optionnel)</label>
                        <textarea id="rating-comment" placeholder="D√©crivez votre exp√©rience sur cet itin√©raire..." style="width: 100%; height: 60px; margin-top: 6px; padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; resize: vertical; font-family: 'DM Sans', sans-serif; font-size: 0.9rem;"></textarea>
                    </div>
                    
                    <div class="rating-buttons">
                        <button class="btn primary" onclick="savePortionRatings()">ÔøΩ‚Äç‚ôÄÔ∏è Noter les portions</button>
                        <button class="btn secondary" onclick="closeRatingPanel()">‚ùå Annuler</button>
                    </div>
                    
                    <div class="rating-info">
                        <strong>Guide :</strong><br>
                        1 = Tr√®s mauvais | 2 = Mauvais | 3 = Moyen | 4 = Bon | 5 = Excellent
                    </div>
                </div>
            </div>
            
            <!-- L√©gende -->
            <div style="margin-top: 1rem; padding: 1rem; background: #f8fafc; border-radius: 8px; font-size: 0.9rem;">
                <strong>üéØ Instructions :</strong> Cliquez sur une piste verte pour la noter selon les 5 crit√®res !
            </div>
        </section>

        <!-- Section Carte Souhait√©es -->
        <section class="section" id="carte-souhaitees">
            <h2>‚ú® Pistes cyclables souhait√©es</h2>
            <p>Proposez de nouveaux trac√©s pour am√©liorer le r√©seau cyclable</p>
            <div class="placeholder">
                Carte avec outils de dessin √† venir...
                <br>Tracez vos pistes id√©ales !
            </div>
        </section>

        <!-- Section √Ä propos -->
        <section class="section" id="apropos">
            <h2>üìã √Ä propos du projet</h2>
            <p><strong>Objectif :</strong> F√©d√©rer la communaut√© cycliste de Bogot√° pour am√©liorer la s√©curit√© et rendre le v√©lo plus attractif.</p>
            
            <div style="margin-top: 2rem;">
                <h3>üéØ Mission</h3>
                <ul style="margin-left: 2rem; margin-top: 0.5rem;">
                    <li>Am√©liorer la s√©curit√© des cyclistes</li>
                    <li>Encourager la participation citoyenne</li>
                    <li>Promouvoir le v√©lo comme alternative √† la voiture</li>
                </ul>
            </div>

            <div style="margin-top: 2rem;">
                <h3>üìß Contact</h3>
                <p>Pour toute question : <strong>contact@rateyourtrack-bogota.com</strong></p>
            </div>
        </section>
    </main>

    <script>
        // Variables globales
        let mapExistantes = null;
        
        // Syst√®me rate_your_track : portions de pistes not√©es par proximit√©
        let portionRatings = JSON.parse(localStorage.getItem('portionRatings') || '{}');
        let portionLayers = []; // Couches visuelles des portions color√©es
        
        // Variables pour le trac√© interactif
        let routePoints = [];
        let routeLayer = null;
        let routeMarkers = [];
        let isTracingMode = false;
        let showRatings = true;
        let currentView = 'global';

        // Navigation simple
        const navButtons = document.querySelectorAll('.nav-btn');
        const sections = document.querySelectorAll('.section');

        navButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Retirer active de tous les boutons et sections
                navButtons.forEach(btn => btn.classList.remove('active'));
                sections.forEach(section => section.classList.remove('active'));
                
                // Activer le bouton cliqu√©
                button.classList.add('active');
                
                // Afficher la section correspondante
                const targetSection = button.getAttribute('data-section');
                document.getElementById(targetSection).classList.add('active');
                
                // Initialiser la carte si on va sur la section carte-existantes
                if (targetSection === 'carte-existantes' && !mapExistantes) {
                    initMapExistantes();
                }
            });
        });

        // Fonction pour initialiser la carte des pistes existantes
        function initMapExistantes() {
            try {
                console.log('Initialisation de la carte...');
                
                // Cr√©er la carte centr√©e sur Bogot√° avec zoom optimal
                mapExistantes = L.map('map-existantes', {
                    maxZoom: 18  // Limiter le zoom max pour √©viter le flou
                }).setView([4.6097, -74.0817], 13);  // Zoom initial un peu plus proche
                
                // Couches de base avec zoom optimis√©
                const baseNeutre = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                    attribution: '¬© OpenStreetMap contributors | ¬© CARTO',
                    maxZoom: 18  // Zoom coh√©rent
                });
                
                const baseStandard = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors',
                    maxZoom: 18  // Zoom coh√©rent
                });
                
                // Ajouter la couche de base par d√©faut
                baseNeutre.addTo(mapExistantes);
                
                // Contr√¥le des couches (seulement les fonds de carte)
                const baseMaps = {
                    "üé® Carte neutre": baseNeutre,
                    "üìç Carte standard": baseStandard
                };
                
                L.control.layers(baseMaps).addTo(mapExistantes);
                
                // Utiliser les donn√©es int√©gr√©es directement (√©vite les probl√®mes CORS)
                console.log('üîç Chargement des pistes cyclables...');
                
                try {
                    if (typeof pistesCyclablesBogota === 'undefined') {
                        throw new Error('Donn√©es des pistes non disponibles');
                    }
                    
                    console.log('‚úÖ Donn√©es charg√©es:', pistesCyclablesBogota.features.length, 'pistes principales');
                    
                    // Ajouter les pistes cyclables √† la carte
                    const pistesLayer = L.geoJSON(pistesCyclablesBogota, {
                        style: function(feature) {
                            // Style uniforme pour toutes les pistes (sans notation directe)
                            return {
                                color: '#22c55e',
                                weight: 3,
                                opacity: 0.8,
                                interactive: false // D√©sactiver compl√®tement les interactions
                            };
                        },
                        onEachFeature: function(feature, layer) {
                            // Pistes compl√®tement non-interactives
                            // Pas de popup, pas de clic, pas d'interaction, pas de tooltip
                        }
                    }).addTo(mapExistantes);
                    
                    console.log('üó∫Ô∏è Pistes ajout√©es √† la carte !');
                    
                    // Ajuster la vue sur les pistes
                    if (pistesCyclablesBogota.features.length > 0) {
                        mapExistantes.fitBounds(pistesLayer.getBounds(), {padding: [20, 20]});
                    }
                    
                } catch (error) {
                    console.error('‚ùå Erreur:', error);
                    L.popup()
                        .setLatLng([4.6097, -74.0817])
                        .setContent(`‚ùå Erreur: ${error.message}`)
                        .openOn(mapExistantes);
                }
                
                // Marqueur centre-ville
                L.marker([4.6097, -74.0817])
                    .addTo(mapExistantes)
                    .bindPopup('üìç Centro de Bogot√°<br>Explorez les pistes cyclables !');
                
                console.log('Carte initialis√©e avec succ√®s !');
                
                // Ajouter la gestion du clic pour le trac√© d'itin√©raire
                mapExistantes.on('click', handleMapClick);
                
                // Afficher les portions not√©es au chargement
                displayPortionRatings();
                
                // Forcer le redimensionnement de la carte
                setTimeout(() => {
                    mapExistantes.invalidateSize();
                }, 200);
                
            } catch (error) {
                console.error('Erreur lors de l\'initialisation de la carte:', error);
                document.getElementById('map-existantes').innerHTML = 
                    '<div style="padding: 2rem; text-align: center; color: #ef4444;">‚ùå Erreur lors du chargement de la carte. V√©rifiez votre connexion internet.</div>';
            }
        }

        // Fonctions pour le syst√®me de notation
        
        function closeRatingPanel() {
            document.getElementById('rating-panel').classList.remove('show');
            currentSegment = null;
        }
        

        
        function saveRating() {
            if (!currentSegment) return;
            
            // Collecter les valeurs des sliders
            const ratings = {
                security: parseInt(document.getElementById('security-slider').value),
                noise: parseInt(document.getElementById('noise-slider').value),
                air: parseInt(document.getElementById('air-slider').value),
                flow: parseInt(document.getElementById('flow-slider').value),
                inclusion: parseInt(document.getElementById('inclusion-slider').value)
            };
            
            // Cas sp√©cial : notation d'un itin√©raire trac√©
            if (currentSegment === 'route') {
                // R√©cup√©rer le commentaire
                const comment = document.getElementById('rating-comment').value.trim();
                
                // Trouver tous les segments intersect√©s par le trac√©
                const intersectedSegments = findIntersectedSegments(routePoints);
                
                // Appliquer la note √† tous les segments intersect√©s
                intersectedSegments.forEach(segmentId => {
                    segmentRatings[segmentId] = ratings;
                });
                localStorage.setItem('segmentRatings', JSON.stringify(segmentRatings));
                
                // Sauvegarder l'itin√©raire not√©
                const routeData = {
                    id: `route_${Date.now()}`,
                    points: [...routePoints],
                    ratings: ratings,
                    comment: comment,
                    intersectedSegments: intersectedSegments,
                    timestamp: new Date().toISOString()
                };
                
                let routeRatings = JSON.parse(localStorage.getItem('routeRatings') || '{}');
                routeRatings[routeData.id] = routeData;
                localStorage.setItem('routeRatings', JSON.stringify(routeRatings));
                
                // Calculer la moyenne
                const average = (ratings.security + ratings.noise + ratings.air + ratings.flow + ratings.inclusion) / 5;
                
                // Colorer l'itin√©raire selon la note et mettre √† jour le popup
                if (routeLayer) {
                    routeLayer.setStyle({
                        color: getColorFromRating(average),
                        weight: 5,
                        opacity: 0.9
                    });
                    
                    // Nouveau popup avec la note (adapt√© selon le type)
                    let popupContent;
                    if (routePoints.length === 1) {
                        popupContent = `
                            <strong>üìç Zone not√©e</strong><br>
                            <strong>üìä Note: ${average.toFixed(1)}/5</strong><br>
                            üõ°Ô∏è S√©curit√©: ${ratings.security}/5<br>
                            üîä Bruit: ${ratings.noise}/5<br>
                            üå¨Ô∏è Air: ${ratings.air}/5<br>
                            ‚ö° Fluidit√©: ${ratings.flow}/5<br>
                            üë• Inclusion: ${ratings.inclusion}/5<br>
                            <small>Rayon d'√©valuation: 80m</small>
                        `;
                    } else {
                        popupContent = `
                            <strong>üõ£Ô∏è Itin√©raire not√©</strong><br>
                            <strong>üìä Note: ${average.toFixed(1)}/5</strong><br>
                            üõ°Ô∏è S√©curit√©: ${ratings.security}/5<br>
                            üîä Bruit: ${ratings.noise}/5<br>
                            üå¨Ô∏è Air: ${ratings.air}/5<br>
                            ‚ö° Fluidit√©: ${ratings.flow}/5<br>
                            üë• Inclusion: ${ratings.inclusion}/5
                        `;
                    }
                    if (comment) {
                        popupContent += `<br><br>üí¨ <em>"${comment}"</em>`;
                    }
                    
                    if (routeLayer) {
                        routeLayer.bindPopup(popupContent);
                    }
                }
                
                // Fermer le panneau
                closeRatingPanel();
                
                // Mettre √† jour les couleurs des segments affect√©s
                updateMapColors();
                
                // Feedback adapt√© selon le type
                let feedbackMessage;
                if (routePoints.length === 1) {
                    feedbackMessage = `‚úÖ Zone not√©e ! Moyenne : ${average.toFixed(1)}/5\nüìç ${intersectedSegments.length} portion${intersectedSegments.length > 1 ? 's' : ''} mise${intersectedSegments.length > 1 ? 's' : ''} √† jour dans un rayon de 80m\nüìç Point conserv√© sur la carte`;
                } else {
                    feedbackMessage = `‚úÖ Itin√©raire not√© ! Moyenne : ${average.toFixed(1)}/5\nüìç ${intersectedSegments.length} portion${intersectedSegments.length > 1 ? 's' : ''} mise${intersectedSegments.length > 1 ? 's' : ''} √† jour\nüõ£Ô∏è Trac√© conserv√© sur la carte`;
                }
                alert(feedbackMessage);
                
                // Sortir du mode trac√© mais GARDER le trac√© visible
                isTracingMode = false;
                const btn = document.getElementById('toggle-tracing');
                const status = document.getElementById('tracing-status');
                btn.textContent = 'üõ£Ô∏è Mode trac√© OFF';
                btn.style.background = '#6b7280';
                status.textContent = '';
                
                return;
            }
            
            // Cas normal : segment individual
            segmentRatings[currentSegment] = ratings;
            localStorage.setItem('segmentRatings', JSON.stringify(segmentRatings));
            
            // Calculer la moyenne pour la couleur
            const average = (ratings.security + ratings.noise + ratings.air + ratings.flow + ratings.inclusion) / 5;
            
            // Mettre √† jour la couleur du segment sur la carte
            updateSegmentColor(currentSegment, average);
            
            // Fermer le panneau
            closeRatingPanel();
            
            // Feedback utilisateur
            alert(`‚úÖ Note sauvegard√©e ! Moyenne : ${average.toFixed(1)}/5`);
        }
        
        function updateSegmentColor(segmentId, average) {
            // Trouver le segment sur la carte et changer sa couleur
            if (mapExistantes && mapExistantes.eachLayer) {
                mapExistantes.eachLayer(layer => {
                    if (layer.feature && layer.feature.id == segmentId) {
                        const color = getColorFromRating(average);
                        layer.setStyle({
                            color: color,
                            weight: 4,
                            opacity: 0.8
                        });
                    }
                });
            }
        }
        
        function getColorFromRating(rating) {
            // Couleurs selon la moyenne (1-5)
            if (rating >= 4) return '#16a34a';  // Vert (bon)
            if (rating >= 3) return '#ca8a04';  // Orange (moyen)
            if (rating >= 2) return '#ea580c';  // Orange fonc√© (mauvais)
            return '#dc2626';  // Rouge (tr√®s mauvais)
        }

        // NOUVELLES FONCTIONS POUR LE TRAC√â INTERACTIF

        function toggleTracingMode() {
            isTracingMode = !isTracingMode;
            const btn = document.getElementById('toggle-tracing');
            const status = document.getElementById('tracing-status');
            const clearBtn = document.getElementById('clear-route-btn');
            
            if (isTracingMode) {
                btn.textContent = 'üõë Mode trac√© ON';
                btn.style.background = '#dc2626';
                status.textContent = 'Placez des points puis notez les pistes proches';
                
                // Ouvrir le panneau de notation
                const ratingPanel = document.getElementById('rating-panel');
                if (ratingPanel) {
                    ratingPanel.classList.add('show');
                    
                    // Mettre un titre par d√©faut
                    const segmentNameEl = document.getElementById('segment-name');
                    if (segmentNameEl) {
                        segmentNameEl.innerHTML = `
                            <strong>üö¥‚Äç‚ôÄÔ∏è Notation des pistes cyclables</strong><br>
                            <small>Placez des points sur la carte puis notez les pistes √† proximit√©</small>
                        `;
                    }
                }
            } else {
                btn.textContent = 'üõ£Ô∏è Mode trac√© OFF';
                btn.style.background = '#6b7280';
                status.textContent = '';
                if (clearBtn) clearBtn.style.display = 'none';
                
                // Fermer le panneau de notation si ouvert
                const ratingPanel = document.getElementById('rating-panel');
                if (ratingPanel) {
                    ratingPanel.classList.remove('show');
                }
                
                // Nettoyer le trac√© en cours
                clearCurrentRoute();
            }
        }

        function toggleRatingsDisplay() {
            showRatings = !showRatings;
            const btn = document.getElementById('toggle-ratings-display');
            
            if (showRatings) {
                btn.textContent = 'üôà Cacher les avis';
                btn.style.background = '#16a34a';
            } else {
                btn.textContent = 'üëÅÔ∏è Afficher les avis';
                btn.style.background = '#6b7280';
            }
            
            // Afficher/cacher les portions rate_your_track
            displayPortionRatings();
        }

        function changeView() {
            const selector = document.getElementById('view-selector');
            if (selector) {
                currentView = selector.value;
                console.log('Vue chang√©e vers:', currentView);
                
                // Mettre √† jour l'affichage des portions selon la vue s√©lectionn√©e
                if (showRatings) {
                    displayPortionRatings();
                }
            }
        }

        function handleMapClick(e) {
            if (!isTracingMode) return;
            
            console.log('Clic en mode trac√©:', e.latlng);
            
            // Ajouter le point au trac√©
            routePoints.push([e.latlng.lng, e.latlng.lat]);
            
            // Cr√©er un marqueur pour ce point
            const marker = L.marker(e.latlng, {
                icon: L.icon({
                    iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
                    shadowSize: [41, 41]
                })
            }).addTo(mapExistantes);
            
            // Clic sur marqueur = supprimer ce point
            marker.on('click', function(evt) {
                evt.originalEvent.stopPropagation();
                const idx = routeMarkers.indexOf(marker);
                if (idx !== -1) removeRoutePoint(idx);
            });
            
            routeMarkers.push(marker);
            
            // Redessiner la ligne
            redrawRouteLine();
            
            // Mettre √† jour le statut
            updateTracingStatus();
        }

        function removeRoutePoint(index) {
            if (index < 0 || index >= routePoints.length) return;
            
            // Supprimer le marqueur
            if (routeMarkers[index]) {
                mapExistantes.removeLayer(routeMarkers[index]);
                routeMarkers.splice(index, 1);
            }
            
            // Supprimer le point
            routePoints.splice(index, 1);
            
            // Redessiner
            redrawRouteLine();
            updateTracingStatus();
        }

        function redrawRouteLine() {
            // Supprimer l'ancienne ligne
            if (routeLayer) {
                mapExistantes.removeLayer(routeLayer);
                routeLayer = null;
            }
            
            // Dessiner la nouvelle ligne si on a assez de points
            if (routePoints.length >= 2) {
                const latLngs = routePoints.map(p => [p[1], p[0]]);
                routeLayer = L.polyline(latLngs, {
                    color: '#2563eb',
                    weight: 4,
                    opacity: 0.8,
                    interactive: true
                }).addTo(mapExistantes);
                
                // Ajouter popup pour noter l'itin√©raire
                routeLayer.bindPopup(`
                    <strong>üõ£Ô∏è Itin√©raire trac√©</strong><br>
                    ${routePoints.length} points<br>
                    <button onclick="rateCurrentRoute()" style="margin-top: 8px; padding: 4px 8px; background: #16a34a; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        ‚≠ê Noter cet itin√©raire
                    </button>
                `);
                
                // Ajouter √©v√©nement de clic sur la ligne
                routeLayer.on('click', function(e) {
                    e.originalEvent.stopPropagation();
                    if (routePoints.length >= 2) {
                        rateCurrentRoute();
                    }
                });
            }
        }

        function updateTracingStatus() {
            const status = document.getElementById('tracing-status');
            const clearBtn = document.getElementById('clear-route-btn');
            
            if (!isTracingMode || !status) {
                if (clearBtn) clearBtn.style.display = 'none';
                return;
            }
            
            const pointCount = routePoints.length;
            if (pointCount === 0) {
                status.textContent = 'Cliquez sur la carte pour commencer la notation';
                if (clearBtn) clearBtn.style.display = 'none';
            } else if (pointCount === 1) {
                status.textContent = '1 point - Panneau de notation ouvert';
                if (clearBtn) clearBtn.style.display = 'inline-block';
            } else {
                status.textContent = `${pointCount} points - Continuez √† tracer ou sauvegardez`;
                if (clearBtn) clearBtn.style.display = 'inline-block';
            }
        }

        function clearCurrentRoute() {
            console.log('Effacement du trac√© en cours...');
            
            // Nettoyer les points et marqueurs (seulement du trac√© en cours)
            routePoints = [];
            routeMarkers.forEach(marker => mapExistantes.removeLayer(marker));
            routeMarkers = [];
            
            // Nettoyer la ligne EN COURS (toujours, pas seulement en mode trac√©)
            if (routeLayer) {
                mapExistantes.removeLayer(routeLayer);
                routeLayer = null;
            }
            
            console.log('Trac√© effac√©');
        }

        function rateCurrentRoute() {
            console.log('rateCurrentRoute appel√©e, routePoints:', routePoints.length);
            
            if (routePoints.length < 1) {
                alert('Placez au moins 1 point pour noter une zone !');
                return;
            }
            
            // Trouver les portions de pistes proches
            const nearbyPortions = findNearbyTrackPortions();
            
            if (nearbyPortions.length === 0) {
                alert('Aucune piste cyclable d√©tect√©e √† proximit√© de votre trac√© (rayon 80m)');
                return;
            }
            
            // Stocker les portions trouv√©es pour la sauvegarde
            window.currentNearbyPortions = nearbyPortions;
            
            console.log('Ouverture du panneau de notation...');
            
            // Ouvrir le panneau de notation
            currentSegment = 'route';
            const segmentNameEl = document.getElementById('segment-name');
            if (segmentNameEl) {
                segmentNameEl.innerHTML = `
                    <strong>ÔøΩ‚Äç‚ôÄÔ∏è Noter ${nearbyPortions.length} portion(s) de pistes</strong><br>
                    <small>Trouv√©es dans un rayon de 80m autour de votre trac√©</small>
                `;
            }
            
            // Valeurs par d√©faut
            ['security', 'noise', 'air', 'flow', 'inclusion'].forEach(criterion => {
                document.getElementById(`${criterion}-slider`).value = 3;
                document.getElementById(`${criterion}-value`).textContent = 3;
            });
            
            // Vider le champ commentaire
            const commentEl = document.getElementById('rating-comment');
            if (commentEl) {
                commentEl.value = '';
            }
            
            // Afficher le panneau
            const panelEl = document.getElementById('rating-panel');
            if (panelEl) {
                console.log('Affichage du panneau de notation');
                panelEl.classList.add('show');
            } else {
                console.error('Panneau rating-panel non trouv√© !');
            }
        }
        
        // Fonction de test simple
        // === SYST√àME RATE_YOUR_TRACK ===
        
        // Trouve les pistes enti√®res proches de l'itin√©raire trac√©
        function findNearbyTrackPortions() {
            if (routePoints.length === 0) return [];
            
            const nearbyTracks = [];
            const foundTrackIds = new Set(); // √âviter les doublons
            const bufferRadius = 80; // 80 m√®tres comme dans rate_your_track
            
            // Pour chaque point de l'itin√©raire
            routePoints.forEach((point, index) => {
                const pointLatLng = L.latLng(point[1], point[0]); // Inverser lng,lat vers lat,lng
                
                // Parcourir toutes les pistes
                pistesCyclablesBogota.features.forEach(feature => {
                    if (feature.geometry.type === 'LineString' && !foundTrackIds.has(feature.id)) {
                        const coords = feature.geometry.coordinates;
                        
                        // V√©rifier si au moins un point de la piste est dans le buffer
                        let isNearby = false;
                        for (let i = 0; i < coords.length && !isNearby; i++) {
                            const coordLatLng = L.latLng(coords[i][1], coords[i][0]);
                            if (pointLatLng.distanceTo(coordLatLng) <= bufferRadius) {
                                isNearby = true;
                            }
                        }
                        
                        if (isNearby) {
                            foundTrackIds.add(feature.id);
                            nearbyTracks.push({
                                id: feature.id,
                                trackName: feature.properties.name || 'Piste cyclable',
                                feature: feature,
                                routePointIndex: index
                            });
                        }
                    }
                });
            });
            
            console.log(`Trouv√© ${nearbyTracks.length} pistes √† proximit√© de l'itin√©raire`);
            return nearbyTracks;
        }
        
        // Sauvegarde la notation d'une piste enti√®re
        function savePortionRating(trackData, ratings) {
            const trackRating = {
                id: trackData.id,
                trackName: trackData.trackName,
                feature: trackData.feature,
                ratings: ratings,
                timestamp: new Date().toISOString(),
                routePointIndex: trackData.routePointIndex
            };
            
            portionRatings[trackData.id] = trackRating;
            localStorage.setItem('portionRatings', JSON.stringify(portionRatings));
            console.log('Piste not√©e et sauvegard√©e:', trackData.id, trackData.trackName);
        }
        
        // Affiche visuellement les pistes not√©es sur la carte
        function displayPortionRatings() {
            // Effacer les anciennes couches
            portionLayers.forEach(layer => mapExistantes.removeLayer(layer));
            portionLayers = [];
            
            if (!showRatings) return;
            
            Object.values(portionRatings).forEach(track => {
                // V√©rifier que la piste et ses donn√©es sont valides
                if (!track || !track.ratings || !track.feature) {
                    console.warn('Piste invalide ignor√©e:', track);
                    return;
                }
                
                const ratings = track.ratings;
                let average = 0;
                let color = '#666666';
                
                // Calculer la moyenne selon la vue active
                if (currentView === 'global') {
                    average = (ratings.security + ratings.noise + ratings.air + ratings.flow + ratings.inclusion) / 5;
                } else {
                    average = ratings[currentView] || 0;
                }
                
                // Couleur selon la note
                if (average >= 4) color = '#00c851'; // Vert
                else if (average >= 3) color = '#ffcc02'; // Jaune
                else if (average >= 2) color = '#ff8800'; // Orange
                else color = '#ff4444'; // Rouge
                
                // Cr√©er une ligne color√©e pour la piste enti√®re
                const trackLayer = L.geoJSON(track.feature, {
                    style: {
                        color: color,
                        weight: 6,
                        opacity: 0.8
                    }
                }).addTo(mapExistantes);
                
                // Tooltip avec d√©tails
                trackLayer.bindTooltip(`
                    <strong>${track.trackName}</strong><br>
                    Note moyenne: ${average.toFixed(1)}/5<br>
                    üõ°Ô∏è S√©curit√©: ${ratings.security}/5<br>
                    üîä Bruit: ${ratings.noise}/5<br>
                    üå¨Ô∏è Air: ${ratings.air}/5<br>
                    ‚ö° Fluidit√©: ${ratings.flow}/5<br>
                    üë• Inclusion: ${ratings.inclusion}/5
                `, { permanent: false, direction: 'top' });
                
                portionLayers.push(trackLayer);
            });
            
            console.log(`Affich√© ${portionLayers.length} pistes not√©es`);
        }
        
        // Rendre les fonctions globales pour les onclick
        window.rateCurrentRoute = rateCurrentRoute;
        window.toggleTracingMode = toggleTracingMode;
        window.toggleRatingsDisplay = toggleRatingsDisplay;
        window.changeView = changeView;
        window.savePortionRatings = savePortionRatings;
        window.closeRatingPanel = closeRatingPanel;
        
        // Nouvelle fonction de sauvegarde pour le syst√®me rate_your_track
        function savePortionRatings() {
            console.log('=== DEBUT savePortionRatings ===');
            
            if (routePoints.length === 0) {
                console.log('Erreur: Aucun point trac√©');
                alert('Placez au moins un point sur la carte pour noter des pistes !');
                return;
            }
            
            console.log('Points trac√©s:', routePoints.length);
            
            // V√©rifier que les √©l√©ments existent
            const securityEl = document.getElementById('security-slider');
            const noiseEl = document.getElementById('noise-slider');
            const airEl = document.getElementById('air-slider');
            const flowEl = document.getElementById('flow-slider');
            const inclusionEl = document.getElementById('inclusion-slider');
            const commentEl = document.getElementById('rating-comment');
            
            console.log('√âl√©ments trouv√©s:', {
                security: !!securityEl,
                noise: !!noiseEl,
                air: !!airEl,
                flow: !!flowEl,
                inclusion: !!inclusionEl,
                comment: !!commentEl
            });
            
            if (!securityEl || !noiseEl || !airEl || !flowEl || !inclusionEl) {
                console.error('Erreur: √âl√©ments de notation manquants');
                alert('Erreur: √âl√©ments de notation non trouv√©s');
                return;
            }
            
            const security = parseInt(securityEl.value);
            const noise = parseInt(noiseEl.value);
            const air = parseInt(airEl.value);
            const flow = parseInt(flowEl.value);
            const inclusion = parseInt(inclusionEl.value);
            const comment = commentEl ? commentEl.value : '';
            
            const ratings = { security, noise, air, flow, inclusion, comment };
            console.log('Ratings √† sauvegarder:', ratings);
            
            // Trouver les pistes proches du trac√© actuel
            const nearbyTracks = findNearbyTrackPortions();
            console.log('Pistes trouv√©es:', nearbyTracks.length);
            
            if (nearbyTracks.length === 0) {
                console.log('Aucune piste trouv√©e √† proximit√©');
                alert('Aucune piste cyclable d√©tect√©e √† proximit√© de votre trac√© (rayon 80m)');
                return;
            }
            
            let savedCount = 0;
            nearbyTracks.forEach((track, index) => {
                console.log(`Sauvegarde piste ${index + 1}:`, track.trackName);
                savePortionRating(track, ratings);
                savedCount++;
            });
            
            console.log(`${savedCount} pistes not√©es et sauvegard√©es`);
            
            // Actualiser l'affichage
            displayPortionRatings();
            
            // Effacer le trac√© apr√®s l'enregistrement
            clearCurrentRoute();
            
            // R√©initialiser les sliders √† la valeur par d√©faut (3)
            document.getElementById('security-slider').value = 3;
            document.getElementById('noise-slider').value = 3;
            document.getElementById('air-slider').value = 3;
            document.getElementById('flow-slider').value = 3;
            document.getElementById('inclusion-slider').value = 3;
            document.getElementById('rating-comment').value = '';
            
            // Message de confirmation
            alert(`‚úÖ ${savedCount} pistes cyclables not√©es avec succ√®s !`);
            console.log('=== FIN savePortionRatings ===');
        }

        function updateMapColors() {
            if (!mapExistantes) return;
            
            // Parcourir toutes les couches de pistes
            mapExistantes.eachLayer(layer => {
                if (layer.feature && layer.feature.id) {
                    const featureId = layer.feature.id;
                    let color = '#22c55e'; // Vert par d√©faut (vue neutre)
                    
                    if (showRatings) {
                        const ratings = segmentRatings[featureId];
                        if (ratings) {
                            let value;
                            switch(currentView) {
                                case 'security':
                                    value = ratings.security;
                                    break;
                                case 'noise':
                                    value = ratings.noise;
                                    break;
                                case 'air':
                                    value = ratings.air;
                                    break;
                                case 'flow':
                                    value = ratings.flow;
                                    break;
                                case 'inclusion':
                                    value = ratings.inclusion;
                                    break;
                                default: // global
                                    value = (ratings.security + ratings.noise + ratings.air + ratings.flow + ratings.inclusion) / 5;
                            }
                            color = getColorFromRating(value);
                        }
                    }
                    
                    layer.setStyle({
                        color: color,
                        weight: 3,
                        opacity: 0.8
                    });
                }
            });
        }

        // SYST√àME DE PORTIONS PR√âCISES (inspir√© de rate_your_track)
        
        function findIntersectedSegments(routePoints) {
            // Simulation simple du buffer 80m et intersection
            // Fonctionne avec 1 seul point (zone) ou plusieurs points (itin√©raire)
            
            const BUFFER_METERS = 80;
            const intersectedSegments = new Set();
            
            if (!window.pistesCyclablesBogota || !routePoints.length) return [];
            
            console.log(`Recherche intersections pour ${routePoints.length} point(s)`);
            
            // Pour chaque point du trac√© (marche avec 1 seul point aussi)
            routePoints.forEach((point, index) => {
                const [lng, lat] = point;
                console.log(`Point ${index + 1}: [${lat.toFixed(4)}, ${lng.toFixed(4)}]`);
                
                // Chercher les segments proches (approximation)
                window.pistesCyclablesBogota.features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    let coordinates = [];
                    if (feature.geometry.type === 'LineString') {
                        coordinates = feature.geometry.coordinates;
                    } else if (feature.geometry.type === 'MultiLineString') {
                        coordinates = feature.geometry.coordinates.flat();
                    }
                    
                    // V√©rifier si le point est proche d'un des points du segment
                    coordinates.forEach(coord => {
                        const distance = calculateDistance(lat, lng, coord[1], coord[0]);
                        if (distance <= BUFFER_METERS) {
                            intersectedSegments.add(feature.id);
                        }
                    });
                });
            });
            
            console.log(`${intersectedSegments.size} segment(s) intersect√©(s)`);
            return Array.from(intersectedSegments);
        }
        
        function calculateDistance(lat1, lng1, lat2, lng2) {
            // Distance euclidienne approximative en m√®tres
            const R = 6371000; // Rayon de la Terre en m√®tres
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Initialiser la carte apr√®s le chargement de la page si Leaflet est disponible
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof L === 'undefined') {
                console.error('Leaflet n\'est pas charg√© !');
                document.getElementById('map-existantes').innerHTML = 
                    '<div style="padding: 2rem; text-align: center; color: #ef4444;">‚ùå Leaflet.js n\'a pas pu se charger</div>';
            } else {
                console.log('Leaflet charg√© avec succ√®s !');
            }
            
            // Initialiser les event listeners pour les sliders de notation
            ['security', 'noise', 'air', 'flow', 'inclusion'].forEach(criterion => {
                const slider = document.getElementById(`${criterion}-slider`);
                if (slider) {
                    slider.addEventListener('input', function() {
                        updateRatingValue(criterion, this.value);
                    });
                }
            });
        });
    </script>
</body>
</html>
